/**
 * @file    decoder.c
 * @author  JHU eCTF Team, MITRE
 * @brief   JHU eCTF Decoder Design Implementation
 * @date    2025
 *
 * This source file is JHU's decoder design for MITRE's 2025 Embedded System CTF (eCTF).
 * This code is being provided only for educational purposes for the 2025 MITRE eCTF competition,
 * and may not meet MITRE standards for quality. Use this code at your own risk!
 *
 */

/*********************** INCLUDES *************************/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>
#include "simple_flash.h"
#include "host_messaging.h"
#include "status_led.h"
#include "simple_uart.h"
#include "simple_crypto.h"
#include "utils.h"

/**********************************************************
 ******************* PRIMITIVE TYPES **********************
 **********************************************************/

#define timestamp_t uint64_t
#define channel_id_t uint32_t
#define decoder_id_t uint32_t
#define pkt_len_t uint16_t

/**********************************************************
 *********************** CONSTANTS ************************
 **********************************************************/

#define MAX_CHANNEL_COUNT 8
#define EMERGENCY_CHANNEL 0
#define FRAME_SIZE 64

#define DEFAULT_CHANNEL_TIMESTAMP 0xFFFFFFFFFFFFFFFF
// This is a canary value so we can confirm whether this decoder has booted before
#define FLASH_FIRST_BOOT 0xDEADBEEF

/**********************************************************
 ********************* STATE MACROS ***********************
 **********************************************************/

// Calculate the flash address where we will store channel info as the 2nd to last page available
#define FLASH_STATUS_ADDR ((MXC_FLASH_MEM_BASE + MXC_FLASH_MEM_SIZE) - (2 * MXC_FLASH_PAGE_SIZE))

// Zhong: Declare the *secrets* symbols generated by objcopy.
extern const unsigned char secrets_bin_start[];
extern const unsigned char secrets_bin_end[];
// Zhong: Load Decoder ID
#ifndef DECODER_ID
#define DECODER_ID 0x0
#endif


/**********************************************************
 *********** COMMUNICATION PACKET DEFINITIONS *************
 **********************************************************/

#pragma pack(push, 1) // Tells the compiler not to pad the struct members
// for more information on what struct padding does, see:
// https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Structure-Layout.html

/**
 * @brief The AES_GCM packet type used for frame data.
 * @author Gavin Zhong
 */
typedef struct {
    uint8_t nonce[IV_SIZE];
    uint8_t ciphertext[FRAME_SIZE]; //for AES_GCM the length of ciphertext is equal to cleartext
    uint8_t tag[TAG_SIZE];
} aes_gcm_packet_frame_t;

/**
 * @brief The frame packet type used for frame data.
 * @author Gavin Zhong
 */
typedef struct {
    // header
    channel_id_t channel;
    timestamp_t timestamp;
    uint8_t data_length;
    // body
    aes_gcm_packet_frame_t data;
    uint8_t signature[SIG_SIZE];
} frame_packet_t;

/**
 * @brief The AES_GCM packet type used for key data.
 * @author Gavin Zhong
 */
typedef struct {
    uint8_t nonce[IV_SIZE];
    uint8_t ciphertext[KEY_SIZE]; //for AES_GCM the length of ciphertext is equal to cleartext
    uint8_t tag[TAG_SIZE];
} aes_gcm_packet_key_t;

/**
 * @brief The subscription update packet type used for key data.
 * @author Gavin Zhong
 */
typedef struct {
    decoder_id_t decoder_id;
    timestamp_t start_timestamp;
    timestamp_t end_timestamp;
    channel_id_t channel;
    aes_gcm_packet_key_t encrypted_channel_key;
    uint8_t signature[SIG_SIZE];
} subscription_update_packet_t;

typedef struct {
    channel_id_t channel;
    timestamp_t start;
    timestamp_t end;
} channel_info_t;

typedef struct {
    uint32_t n_channels;
    channel_info_t channel_info[MAX_CHANNEL_COUNT];
} list_response_t;

#pragma pack(pop) // Tells the compiler to resume padding struct members

/**********************************************************
 ******************** TYPE DEFINITIONS ********************
 **********************************************************/

typedef struct {
    bool active;
    channel_id_t id;
    timestamp_t start_timestamp;
    timestamp_t end_timestamp;
    uint8_t channel_key[KEY_SIZE];  // AES-256 keys for decrypting frames
} channel_status_t;

typedef struct {
    uint32_t first_boot; // if set to FLASH_FIRST_BOOT, device has booted before.
    channel_status_t subscribed_channels[MAX_CHANNEL_COUNT];
} flash_entry_t;


/**
 * @brief The secrets struct used to store the subscription key and signature public key.
 * @author Liz Grzyb
 */
typedef struct {
    uint8_t subscription_key[KEY_SIZE];  // AES-256 key for subscription updates
    uint8_t signature_public_key[KEY_SIZE];  // ECC public key for verifying signatures
} secrets_t;

/**********************************************************
 ************************ GLOBALS *************************
 **********************************************************/

// This is used to track decoder subscriptions
flash_entry_t decoder_status;
// Liz - this is to store the secrets in RAM
secrets_t decoder_secrets;
// Zhong - global timestamp
static timestamp_t last_valid_timestamp = 0;

/**********************************************************
 ******************* UTILITY FUNCTIONS ********************
 **********************************************************/

/**
 * @brief Loads subscription key, public key from linked object file into the global variable decoder_secrets
 * @author Gavin Zhong
 */
void load_secrets() {
    if (secrets_bin_end - secrets_bin_start != 64) {
        // print_error("Secrets bin size is not 64 bytes, indicating a format error\n");
        print_error("error");
        // The caller has violated the function's contract,
        // this can only be caused by a hardware fault.
        HALT_AND_CATCH_FIRE();
        return;
    }
    SECURE_MEMCPY(&decoder_secrets, secrets_bin_start, 64);
}

/** @brief Checks whether the decoder is subscribed to a given channel
 *
 *  @param channel The channel number to be checked.
 *  @return 1 if the the decoder is subscribed to the channel.  0 if not.
*/
int is_subscribed(channel_id_t channel) {
    // Check if this is an emergency broadcast message
    if (channel == EMERGENCY_CHANNEL) {
        return 1;
    }
    // Check if the decoder has has a subscription
    for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == channel && decoder_status.subscribed_channels[i].active) {
            return 1;
        }
    }
    return 0;
}

/**********************************************************
 ********************* CORE FUNCTIONS *********************
 **********************************************************/

/** @brief Lists out the actively subscribed channels over UART.
 *
 *  @return 0 if successful.
*/
int list_channels() {
    list_response_t resp;
    pkt_len_t len;

    resp.n_channels = 0;

    for (uint32_t i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].active) {
            resp.channel_info[resp.n_channels].channel =  decoder_status.subscribed_channels[i].id;
            resp.channel_info[resp.n_channels].start = decoder_status.subscribed_channels[i].start_timestamp;
            resp.channel_info[resp.n_channels].end = decoder_status.subscribed_channels[i].end_timestamp;
            resp.n_channels++;
        }
    }

    len = sizeof(resp.n_channels) + (sizeof(channel_info_t) * resp.n_channels);

    // Success message
    SEC_ASSERT((volatile uint32_t) resp.n_channels <= MAX_CHANNEL_COUNT);
    SEC_ASSERT((volatile uint16_t) len == (sizeof(resp.n_channels) + (sizeof(channel_info_t) * (volatile uint32_t) resp.n_channels)));
    write_packet(LIST_MSG, &resp, len);
    return 0;
}


/** @brief Updates the channel subscription for a subset of channels.
 *
 *  @param pkt_len The length of the incoming packet
 *  @param update A pointer to an array of channel_update structs,
 *      which contains the channel number, start, and end timestamps
 *      for each channel being updated.
 *
 *  @note Take care to note that this system is little endian.
 *
 *  @return 0 upon success.  -1 if error.
*/
int update_subscription(pkt_len_t pkt_len, subscription_update_packet_t *update) {
    if (update == NULL) {
        STATUS_LED_RED();
        print_error("error");
        // The caller has violated the function's contract,
        // this can only be caused by a hardware fault.
        HALT_AND_CATCH_FIRE();
        return -1;
    }

    if (update->channel == EMERGENCY_CHANNEL) {
        STATUS_LED_RED();
        print_error("error");
        return -1;
    }
    int i;
    volatile int auth_ret = 1;
    volatile int decrypt_ret = 1;
    volatile int decode_ret = 1;
    
    // Zhong: verify the signature
    unsigned int message = sizeof(subscription_update_packet_t) - SIG_SIZE;
    auth_ret = ed25519_authenticate(update->signature, (u_int8_t *)update, message,
                 decoder_secrets.signature_public_key);
    // Zhong: if invalid signature, return error
    if (auth_ret != 0 || auth_ret != 0 || auth_ret != 0) {
        STATUS_LED_RED();
        print_error("error");
        // Catch attacker
        MAX_DELAY();
        return -1;
    }
    
    // Zhong: verify the decoder ID
    decode_ret = (DECODER_ID != update->decoder_id);
    if (decode_ret != 0 || decode_ret != 0 || decode_ret != 0) {
        STATUS_LED_RED();
        print_error("error");
        // Catch attacker
        MAX_DELAY();
        return -1;
    }

    // Zhong: Decrypt the subscription to get channel key
    u_int8_t channel_key[KEY_SIZE] = {0};
    decrypt_ret = aes_gcm_decrypt((uint8_t *)update->encrypted_channel_key.ciphertext, KEY_SIZE,
                     decoder_secrets.subscription_key, (uint8_t *)update->encrypted_channel_key.nonce, (uint8_t *)update->encrypted_channel_key.tag, (uint8_t *)channel_key);
    if ((volatile int) auth_ret != 0 || (volatile int) decrypt_ret != 0 || (volatile int) decode_ret != 0) {
        STATUS_LED_RED();
        // print_error("Failed to update subscription - invalid subscription key\n");
        print_error("error");
        secure_wipe(channel_key, KEY_SIZE);
        // The caller has violated the function's contract,
        // the decryption failure after authentication can only be caused by a hardware fault.
        HALT_AND_CATCH_FIRE();
        return -1;
    }

    // Find the first empty slot in the subscription array
    for (i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == update->channel || !decoder_status.subscribed_channels[i].active) {
            decoder_status.subscribed_channels[i].active = true;
            decoder_status.subscribed_channels[i].id = update->channel;
            decoder_status.subscribed_channels[i].start_timestamp = update->start_timestamp;
            decoder_status.subscribed_channels[i].end_timestamp = update->end_timestamp;
            // Zhong: repetition check against fault injection
            SEC_ASSERT((volatile bool) decoder_status.subscribed_channels[i].active == true \
             && (volatile channel_id_t) decoder_status.subscribed_channels[i].id == (volatile channel_id_t) update->channel \
             && (volatile timestamp_t) decoder_status.subscribed_channels[i].start_timestamp == (volatile timestamp_t) update->start_timestamp \
             && (volatile timestamp_t) decoder_status.subscribed_channels[i].end_timestamp == (volatile timestamp_t) update->end_timestamp);
            // Zhong: Store the channel key
            SECURE_MEMCPY(decoder_status.subscribed_channels[i].channel_key, channel_key, KEY_SIZE);
            secure_wipe(channel_key, KEY_SIZE);
            break;
        }
    }

    // If we do not have any room for more subscriptions
    if (i == MAX_CHANNEL_COUNT) {
        STATUS_LED_RED();
        print_error("error");
        secure_wipe(channel_key, KEY_SIZE);
        return -1;
    }

    flash_simple_erase_page(FLASH_STATUS_ADDR);
    flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));

    SEC_ASSERT((volatile int) auth_ret == 0);
    SEC_ASSERT((volatile uint32_t) DECODER_ID == (volatile uint32_t) update->decoder_id);
    // Success message with an empty body
    write_packet(SUBSCRIBE_MSG, NULL, 0);

    secure_wipe(channel_key, KEY_SIZE);
    return 0;
}

/** @brief Processes a packet containing frame data.
 *
 *  @param pkt_len A pointer to the incoming packet.
 *  @param new_frame A pointer to the incoming packet.
 *
 *  @return 0 if successful.  -1 if data is from unsubscribed channel.
*/
int decode(pkt_len_t pkt_len, frame_packet_t *new_frame) {
    char output_buf[128] = {0};
    u_int8_t channel_key[KEY_SIZE] = {0};
    channel_id_t channel = new_frame->channel;
    unsigned int message_size = 0;
    u_int8_t sub_time_valid = 1;
    u_int8_t decrypted_frame[FRAME_SIZE] = {0};
    volatile int ret = -1;

    // Zhong: Input Validation
    if ((volatile uint8_t) new_frame->data_length != (volatile pkt_len_t) (pkt_len - IV_SIZE - TAG_SIZE - SIG_SIZE - 4 - 8 - 1) || (volatile uint8_t) new_frame->data_length < 0 || (volatile uint8_t) new_frame->data_length > FRAME_SIZE) {
        STATUS_LED_RED();
        // print_error("fault injection detected\n");
        print_error("error");
        // The caller has violated the function's contract,
        // this can only be caused by a hardware fault.
        HALT_AND_CATCH_FIRE();
        return -1;
    }

    // Zhong: verify the signature; repeated computation against fault injection
    message_size = pkt_len - SIG_SIZE;
    volatile int auth_ret = ed25519_authenticate(new_frame->signature, (u_int8_t *)new_frame, message_size,
                 decoder_secrets.signature_public_key);
    // Zhong: if invalid signature, return error
    if (auth_ret != 0 || auth_ret != 0 || auth_ret != 0) {
        STATUS_LED_RED();
        print_error("error");
        // Catch attacker
        MAX_DELAY();
        return -1;
    }
    // Zhong: global timestamp check
    volatile int time_check = new_frame->timestamp <= last_valid_timestamp;
    if (time_check != 0 || time_check != 0 || time_check != 0) {
        STATUS_LED_RED();
        print_error("error");
        return -1;
    }
    // Check that we are subscribed to the channel
    volatile int subscribed = is_subscribed(channel);
    if (subscribed != 1 || subscribed != 1 || subscribed != 1) {
        STATUS_LED_RED();
        sprintf(output_buf, "error");
        print_error(output_buf);
        return -1;
    }
    // Zhong: subscription timestamp check; though this operation can be merged into the following key lookup
    // we seperate it here for safety issue
    for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == channel) {
            // Zhong: Pass the timestamp check for emergency channel
            sub_time_valid = new_frame->timestamp < decoder_status.subscribed_channels[i].start_timestamp || 
             new_frame->timestamp > decoder_status.subscribed_channels[i].end_timestamp;
            if (sub_time_valid && channel != EMERGENCY_CHANNEL) {
                STATUS_LED_RED();
                // print_error("Failed to decrypt frame - inactive subscription \n");
                print_error("error");
                return -1;
            }
            break;
        }
    }
    // Zhong: fault injection check
    if ((volatile int) auth_ret | (volatile int) time_check | (volatile int) subscribed != 1 | ((volatile u_int8_t) sub_time_valid && (volatile uint32_t) channel != EMERGENCY_CHANNEL)) {
        STATUS_LED_RED();
        // print_error("Fault injection detected\n");
        print_error("error");
        // The caller has violated the function's contract,
        // this can only be caused by a hardware fault.
        HALT_AND_CATCH_FIRE();
        return -1;
    }
    // Zhong: Ready for decryption.Looking for the persistent channel key
    for (int i = 0; i < MAX_CHANNEL_COUNT; i++) {
        if (decoder_status.subscribed_channels[i].id == channel) {
             SECURE_MEMCPY(channel_key, decoder_status.subscribed_channels[i].channel_key, KEY_SIZE);
             break;
        }
    }
    // Zhong: Decrypt the encrypted frame
    if (channel == EMERGENCY_CHANNEL) { 
        memcpy(decrypted_frame, new_frame->data.ciphertext, new_frame->data_length);
    } else {
        ret = aes_gcm_decrypt((uint8_t *)new_frame->data.ciphertext, new_frame->data_length,
                        channel_key, (uint8_t *)new_frame->data.nonce, (uint8_t *)new_frame->data.tag, (uint8_t *)decrypted_frame);
        if (ret != 0 || ret != 0 || ret != 0) {
            STATUS_LED_RED();
            // print_error("Failed to decrypt frame - invalid channel key\n");
            print_error("error");
            secure_wipe(channel_key, KEY_SIZE);
            secure_wipe(decrypted_frame, sizeof(decrypted_frame));
            // The caller has violated the function's contract,
            // this can only be caused by a hardware fault.
            HALT_AND_CATCH_FIRE();
            return -1;
        }
    }
    // Zhong: global timestamp check before rewrite
    if ((volatile timestamp_t) new_frame->timestamp <= (volatile timestamp_t) last_valid_timestamp) {
        STATUS_LED_RED();
        // print_error("Failed to decrypt frame - invalid timestamp - chaos\n");
        print_error("error");
        secure_wipe(channel_key, KEY_SIZE);
        secure_wipe(decrypted_frame, sizeof(decrypted_frame));
        // The caller has violated the function's contract,
        // this can only be caused by a hardware fault.
        HALT_AND_CATCH_FIRE();
        return -1;
    }
    // Zhong: Update global state after all checks
    last_valid_timestamp = new_frame->timestamp;
    SEC_CHECK((volatile timestamp_t) last_valid_timestamp == (volatile timestamp_t) new_frame->timestamp);

    // Zhong: Send the decrypted frame to host
    write_packet(DECODE_MSG, decrypted_frame, new_frame->data_length);

    // Zhong: Clean up
    secure_wipe(channel_key, KEY_SIZE);
    secure_wipe(decrypted_frame, FRAME_SIZE);
    return 0;
}

/** @brief Initializes peripherals for system boot.
*/
void init() {
    int ret;
    // Initialize the flash peripheral to enable access to persistent memory
    flash_simple_init();
    // Liz: Disable unused peripherals
    disable_i2c();
    disable_irq();
    disable_cache();
    // Zhong: initialize RNG
    rng_init();
    // Zhong: Add a delay to ensure RNG is ready
    get_random_delay_us(100);
    // Zhong: Load Secrets
    load_secrets();

    // Read starting flash values into our flash status struct
    flash_simple_read(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    if (decoder_status.first_boot != FLASH_FIRST_BOOT) {
        /* If this is the first boot of this decoder, mark all channels as unsubscribed.
        *  This data will be persistent across reboots of the decoder. Whenever the decoder
        *  processes a subscription update, this data will be updated.
        */
        print_debug("First boot.  Setting flash...\n");

        decoder_status.first_boot = FLASH_FIRST_BOOT;

        channel_status_t subscription[MAX_CHANNEL_COUNT];

        for (int i = 0; i < MAX_CHANNEL_COUNT; i++){
            subscription[i].start_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
            subscription[i].end_timestamp = DEFAULT_CHANNEL_TIMESTAMP;
            subscription[i].active = false;
        }

        // Write the starting channel subscriptions into flash.
        SECURE_MEMCPY(decoder_status.subscribed_channels, subscription, MAX_CHANNEL_COUNT*sizeof(channel_status_t));

        flash_simple_erase_page(FLASH_STATUS_ADDR);
        flash_simple_write(FLASH_STATUS_ADDR, &decoder_status, sizeof(flash_entry_t));
    }

    // Initialize the uart peripheral to enable serial I/O
    ret = uart_init();
    if (ret < 0) {
        STATUS_LED_ERROR();
        // if uart fails to initialize, do not continue to execute
        while (1);
    }
}
/**********************************************************
 *********************** MAIN LOOP ************************
 **********************************************************/

int main(void) {
    char output_buf[128] = {0};
    uint8_t uart_buf[100];
    msg_type_t cmd;
    int result;
    uint16_t pkt_len;

    // initialize the device
    init();

    print_debug("Decoder Booted!\n");

    // process commands forever
    while (1) {
        print_debug("Ready\n");

        STATUS_LED_GREEN();

        result = read_packet(&cmd, uart_buf, &pkt_len);

        if (result < 0) {
            STATUS_LED_ERROR();
            print_error("Failed to receive cmd from host\n");
            continue;
        }

        // Handle the requested command
        switch (cmd) {

        // Handle list command
        case LIST_MSG:
            STATUS_LED_CYAN();
            list_channels();
            break;

        // Handle decode command
        case DECODE_MSG:
            /*STATUS_LED_PURPLE();*/
            decode(pkt_len, (frame_packet_t *)uart_buf);
            break;

        // Handle subscribe command
        case SUBSCRIBE_MSG:
            STATUS_LED_YELLOW();
            update_subscription(pkt_len, (subscription_update_packet_t *)uart_buf);
            break;

        // Handle bad command
        default:
            STATUS_LED_ERROR();
            sprintf(output_buf, "Invalid Command: %c\n", cmd);
            print_error(output_buf);
            break;
        }
    }
}
