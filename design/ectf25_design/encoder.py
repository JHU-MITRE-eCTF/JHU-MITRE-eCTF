"""
Author: Ben Janis
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""
import argparse
import struct
from Crypto.Cipher import AES
from Crypto.Signature import eddsa
from ectf25_design.gen_secrets import load_secret
from ectf25_design.utils import *

DEBUG_MODE = True

class Encoder:
    def __init__(self, secrets: bytes):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        # TODO: parse your secrets data here and run any necessary pre-processing to
        #   improve the throughput of Encoder.encode

        secrets = load_secret(secrets)
        self.channel_keys = secrets["channel_keys"]
        self.sub_key = secrets["subscription_key"]
        self.sign_key_private = secrets["signature_private_key"]
        self.sign_key_public = secrets["signature_public_key"]

    # def pad_bytes(self, frame: bytes, max_width: int) -> bytes:
    #     """Pads the frame to the max_width number of bytes.
    #     Rather than using null bytes (\0), which may be problematic
    #     if the frame contains legitimate null bytes in the final 
    #     x bytes, pad the frame with the number of bytes padded.
    #     Example: For a 60-byte frame, we would pad the last 4 bytes 
    #     with the bytevalue of 4 (\x04).

    #     This ensures that all frames have a size of 64 bytes
    #     to prevent leakage of the length of the data being
    #     transmitted over the air from the uplink/satellite systems.

    #     :param frame: Bytestring of <= 64 bytes
    #     :param max_width: Length that the fame should be padded to

    #     :returns: The padded frame, which will be encoded by encode()
    #     """
    #     # Check that the frame length is less than max_width
    #     if len(frame) == max_width:
    #         return frame

    #     num_padded_bytes = max_width - len(frame)
    #     if DEBUG_MODE:
    #         print(f'Length of frame: {len(frame)}. Need {num_padded_bytes} bytes of padding.')
        
    #     for i in range(num_padded_bytes):
    #         frame += bytes([ord(chr(num_padded_bytes))])
        
    #     return frame

    # def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
    #     """The frame encoder function

    #     This will be called for every frame that needs to be encoded before being
    #     transmitted by the satellite to all listening TVs

    #     You **may not** change the arguments or returns of this function!

    #     :param channel: 16b unsigned channel number. Channel 0 is the emergency
    #         broadcast that must be decodable by all channels.
    #     :param frame: Frame to encode. Max frame size is 64 bytes.
    #     :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
    #         have no relation to the current timestamp, so you should not compare it
    #         against the current time. The timestamp is guaranteed to strictly
    #         monotonically increase (always go up) with subsequent calls to encode

    #     :returns: The encoded frame, which will be sent to the Decoder
    #     """
    #     # Combine the channel/timestamp + frame
    #     # Ensure that the channel/timestamp metadata are padded to be 10 bytes
    #     # 16 bits - channel num; 64 bits - timestamp
    #     # TODO: Pad the frame to be up to 64 bytes, so payload is struct.pack("<IQ64s", channel, timestamp, frame)
    #     payload = struct.pack("<IQ", channel, timestamp)
    #     if DEBUG_MODE:
    #         print(payload)
    #         print(len(struct.pack("<IQ", channel, timestamp)))

    #     # Encrypt payload using AES-256-GCM
    #     encrypt_key = self.channel_keys[channel]
    #     encrypt_key = bytes(bytearray.fromhex(encrypt_key))
    #     assert len(encrypt_key) == 32

    #     # Encrypted payload should be 74 bytes (64 bytes from frame, 8 bytes from timestamp, 2 bytes for channel num)
    #     cipher = AES.new(encrypt_key, AES.MODE_GCM)
    #     encrypted_frame = cipher.encrypt(self.pad_bytes(frame, 64))
    #     final_payload = payload + encrypted_frame

    #     # Sign payload using ED25519
    #     signing_key = bytes(bytearray.fromhex(self.sign_key_private))
    #     signing_key = eddsa.import_private_key(signing_key)
    #     signer = eddsa.new(signing_key, 'rfc8032')     # https://datatracker.ietf.org/doc/html/rfc8032#section-3.2

    #     # Signature should be 64 bytes long (!!)
    #     signature = signer.sign(final_payload)

    #     # Current implementation uses all 64 bytes, meaning we would be
    #     # doubling the traffic. May need to consider using first/last x bytes
    #     # going forward!
    #     return final_payload + signature
    
    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs

        You **may not** change the arguments or returns of this function!

        :param channel: 32b unsigned channel number. Channel 0 is the emergency
            broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
            have no relation to the current timestamp, so you should not compare it
            against the current time. The timestamp is guaranteed to strictly
            monotonically increase (always go up) with subsequent calls to encode

        :returns: The encoded frame, which will be sent to the Decoder
        """
        
        if channel == 0:
            # no encryption for channel 0
            nonce, ciphertext, tag = b'\x00', frame, b'\x00'
        else:
        # encrypt frame: nonce + ciphertext + tag
            nonce, ciphertext, tag = aes_gcm_encrypt_split(frame, self.channel_keys[channel])
        # sign frame
        signature = ed25519_sign(struct.pack(f"<IQB12s64s16s",  channel, timestamp, len(frame), nonce, ciphertext, tag),\
                self.sign_key_private)
        """
        :format specification for packets:
            --- header
            4 bytes: channel_number (unsigned int)
            8 bytes: timestamp (unsigned int)
            1 byte ciphertext_length (unsigned int)
            --- body
            92 bytes: encrypted_frame (12 bytes nounce + 64 bytes ciphertext(vary) + 16 bytes tag)
            64 bytes: ed25519_signature (sign channel_number+timestamp+ciphertext_length+encrypted_frame)
        """
        ret = struct.pack(f"<IQB12s64s16s64s", channel, timestamp, len(frame), nonce, ciphertext, tag, signature)
        if DEBUG_MODE:
            print(f"{channel} {timestamp} {nonce} {ciphertext} {tag} {signature}")
            print(f"length: {len(ret)}")
        assert ed25519_verify(ret[-64:], ret[:-64], self.sign_key_public) == True, "signature generation error"
        return ret



def main():
    """A test main to one-shot encode a frame

    This function is only for your convenience and will not be used in the final design.

    After pip-installing, you should be able to call this with:
        python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
    parser.add_argument(
        "secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
    )
    parser.add_argument("channel", type=int, help="Channel to encode for")
    parser.add_argument("frame", help="Contents of the frame")
    parser.add_argument("timestamp", type=int, help="64b timestamp to use")

    args = parser.parse_args()

    encoder = Encoder(args.secrets_file.read())
    print(repr(encoder.encode(args.channel, args.frame.encode(), args.timestamp)))


if __name__ == "__main__":
    main()